import { Request, Response, NextFunction } from 'express'
import { supabase } from '../lib/supabase.js'
import bcrypt from 'bcryptjs'

// ============================================
// TYPES
// ============================================

export interface CustomerContext {
  customerId: string
  email: string
  name: string | null
  phone: string | null
  hasPassword: boolean
}

export interface CustomerSession {
  customerId: string
  email: string
  token: string
  expiresAt: Date
}

// Extend Express Request to include customer context
declare global {
  namespace Express {
    interface Request {
      customerContext?: CustomerContext
    }
  }
}

// ============================================
// HELPER FUNCTIONS
// ============================================

// Token is generated by database as UUID

/**
 * Get customer by email
 */
export async function getCustomerByEmail(email: string) {
  const { data, error } = await supabase
    .from('customers')
    .select('*')
    .eq('email', email.toLowerCase())
    .single()

  if (error && error.code !== 'PGRST116') {
    console.error('Error fetching customer:', error)
    return null
  }

  return data
}

/**
 * Get customer by ID
 */
export async function getCustomerById(id: string) {
  const { data, error } = await supabase
    .from('customers')
    .select('*')
    .eq('id', id)
    .single()

  if (error) {
    console.error('Error fetching customer:', error)
    return null
  }

  return data
}

/**
 * Create or get customer by email
 */
export async function getOrCreateCustomer(email: string, name?: string, phone?: string) {
  const existingCustomer = await getCustomerByEmail(email)

  if (existingCustomer) {
    // Update name/phone if provided and customer doesn't have them
    if ((name && !existingCustomer.name) || (phone && !existingCustomer.phone)) {
      const { data } = await supabase
        .from('customers')
        .update({
          name: name || existingCustomer.name,
          phone: phone || existingCustomer.phone,
          updated_at: new Date().toISOString()
        })
        .eq('id', existingCustomer.id)
        .select()
        .single()
      return data || existingCustomer
    }
    return existingCustomer
  }

  // Create new customer
  const { data, error } = await supabase
    .from('customers')
    .insert({
      email: email.toLowerCase(),
      name: name || null,
      phone: phone || null
    })
    .select()
    .single()

  if (error) {
    console.error('Error creating customer:', error)
    return null
  }

  return data
}

/**
 * Create magic link token for customer
 */
export async function createMagicLinkToken(customerId: string, ipAddress?: string, userAgent?: string) {
  // Invalidate any existing unused tokens for this customer
  await supabase
    .from('customer_access_tokens')
    .delete()
    .eq('customer_id', customerId)
    .eq('token_type', 'magic_link')
    .is('used_at', null)

  // Create new token (expires in 1 hour)
  const { data, error } = await supabase
    .from('customer_access_tokens')
    .insert({
      customer_id: customerId,
      token_type: 'magic_link',
      expires_at: new Date(Date.now() + 60 * 60 * 1000).toISOString(),
      ip_address: ipAddress || null,
      user_agent: userAgent || null
    })
    .select()
    .single()

  if (error) {
    console.error('Error creating magic link token:', error)
    return null
  }

  return data
}

/**
 * Verify magic link token
 */
export async function verifyMagicLinkToken(token: string) {
  const { data, error } = await supabase
    .from('customer_access_tokens')
    .select('*, customers(*)')
    .eq('token', token)
    .eq('token_type', 'magic_link')
    .is('used_at', null)
    .gt('expires_at', new Date().toISOString())
    .single()

  if (error || !data) {
    return null
  }

  // Mark token as used
  await supabase
    .from('customer_access_tokens')
    .update({ used_at: new Date().toISOString() })
    .eq('id', data.id)

  // Update customer last login
  await supabase
    .from('customers')
    .update({ last_login_at: new Date().toISOString() })
    .eq('id', data.customer_id)

  return data.customers
}

/**
 * Create session token for customer (stored in customer_access_tokens)
 */
export async function createSessionToken(customerId: string) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days

  // Let database generate the UUID token via default
  const { data, error } = await supabase
    .from('customer_access_tokens')
    .insert({
      customer_id: customerId,
      token_type: 'booking_access', // Reusing this type for session
      expires_at: expiresAt.toISOString()
    })
    .select()
    .single()

  if (error) {
    console.error('Error creating session token:', error)
    return null
  }

  return {
    token: data.token,
    expiresAt: expiresAt
  }
}

/**
 * Verify session token
 */
export async function verifySessionToken(token: string) {
  const { data, error } = await supabase
    .from('customer_access_tokens')
    .select('*, customers(*)')
    .eq('token', token)
    .eq('token_type', 'booking_access')
    .is('used_at', null) // Session tokens are not marked as used until logout
    .gt('expires_at', new Date().toISOString())
    .single()

  if (error || !data || !data.customers) {
    return null
  }

  return data.customers
}

/**
 * Invalidate session token (logout)
 */
export async function invalidateSessionToken(token: string) {
  const { error } = await supabase
    .from('customer_access_tokens')
    .update({ used_at: new Date().toISOString() })
    .eq('token', token)

  return !error
}

/**
 * Verify customer password
 */
export async function verifyCustomerPassword(email: string, password: string) {
  const customer = await getCustomerByEmail(email)

  if (!customer || !customer.password_hash) {
    return null
  }

  const isValid = await bcrypt.compare(password, customer.password_hash)

  if (!isValid) {
    return null
  }

  // Update last login
  await supabase
    .from('customers')
    .update({ last_login_at: new Date().toISOString() })
    .eq('id', customer.id)

  return customer
}

/**
 * Set customer password
 */
export async function setCustomerPassword(customerId: string, password: string) {
  const passwordHash = await bcrypt.hash(password, 10)

  const { data, error } = await supabase
    .from('customers')
    .update({
      password_hash: passwordHash,
      updated_at: new Date().toISOString()
    })
    .eq('id', customerId)
    .select()
    .single()

  if (error) {
    console.error('Error setting password:', error)
    return null
  }

  return data
}

// ============================================
// MIDDLEWARE
// ============================================

/**
 * Middleware to attach customer context from session token
 * Looks for token in Authorization header or x-customer-token header
 */
export async function attachCustomerContext(req: Request, res: Response, next: NextFunction) {
  const authHeader = req.headers.authorization
  const customerToken = req.headers['x-customer-token'] as string

  let token: string | null = null

  if (authHeader && authHeader.startsWith('Bearer ')) {
    token = authHeader.split(' ')[1]
  } else if (customerToken) {
    token = customerToken
  }

  if (!token) {
    return next()
  }

  try {
    const customer = await verifySessionToken(token)

    if (!customer) {
      return next()
    }

    req.customerContext = {
      customerId: customer.id,
      email: customer.email,
      name: customer.name,
      phone: customer.phone,
      hasPassword: !!customer.password_hash
    }

    next()
  } catch (error) {
    console.error('Error in attachCustomerContext:', error)
    next()
  }
}

/**
 * Middleware to require customer authentication
 */
export function requireCustomerAuth(req: Request, res: Response, next: NextFunction) {
  if (!req.customerContext) {
    return res.status(401).json({ error: 'Unauthorized', message: 'Customer authentication required' })
  }
  next()
}

/**
 * Get bookings for a customer across all tenants
 */
export async function getCustomerBookings(customerId: string) {
  const { data, error } = await supabase
    .from('bookings')
    .select(`
      *,
      tenants (
        id,
        business_name,
        logo_url
      )
    `)
    .eq('customer_id', customerId)
    .order('check_in', { ascending: false })

  if (error) {
    console.error('Error fetching customer bookings:', error)
    return []
  }

  return data || []
}

/**
 * Check if customer can modify booking add-ons
 * Only allowed before check-in date
 */
export function canModifyBookingAddons(booking: any): boolean {
  const checkInDate = new Date(booking.check_in)
  const now = new Date()
  return checkInDate > now
}
